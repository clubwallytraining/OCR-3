<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- 
    By using maximum-scale=1.0 and user-scalable=no, we ensure orientation-based resizing 
    behaves consistently on mobile devices.
  -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Fullscreen Camera Stream + OpenCV (MediaStreamTrackProcessor)</title>
  
  <!-- Video.js CSS (no integrity checks) -->
  <link
    href="https://vjs.zencdn.net/8.0.4/video-js.css"
    rel="stylesheet"
  >

  <!-- OpenCV.js from official docs/cdn (example version 4.6.0). Adjust version as needed. -->
  <script src="https://docs.opencv.org/4.6.0/opencv.js" defer></script>
  
  <!-- Dark Theme Styling -->
  <style>
    :root {
      --background-color: #121212;
      --text-color: #ffffff;
      --button-bg: rgba(31, 31, 31, 0.8);
      --button-hover-bg: rgba(51, 51, 51, 0.8);
      --font-family: Arial, sans-serif;
      --modal-background: rgba(0, 0, 0, 0.8);
      --modal-content-bg: #1f1f1f;
      --modal-text-color: #ffffff;
      --fps-bg: rgba(0, 0, 0, 0.5);
      --button-font-size: 16px;
      --button-padding: 12px 24px;
      --fps-target: 120;
      --fps-acceptable: 60;
    }
    
    /* Reset and base styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      color: var(--text-color);
      font-family: var(--font-family);
      position: relative;
    }

    /* Video container */
    #camera-stream {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: black;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Controls styling */
    .controls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 2;
    }
    
    .control-button {
      background-color: var(--button-bg);
      border: none;
      border-radius: 25px;
      color: var(--text-color);
      padding: var(--button-padding);
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: var(--button-font-size);
      min-width: 150px;
      text-align: center;
    }
    
    .control-button:hover {
      background-color: var(--button-hover-bg);
    }
    
    /* FPS Counter (Browser Render) */
    #fps-counter {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      background: var(--fps-bg);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .fps-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: green;
    }

    /* Orientation Indicator */
    #orientation-indicator {
      position: fixed;
      bottom: 20px;
      left: 120px; 
      color: #fff;
      background: var(--fps-bg);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .orientation-indicator-circle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: blue;
    }

    /* Camera FPS Indicator (Actual camera capture rate) */
    #camera-fps-indicator {
      position: fixed;
      bottom: 20px;
      left: 270px;
      color: #fff;
      background: var(--fps-bg);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .camera-fps-indicator-circle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: orange;
    }

    /* Loading Indicator */
    #loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--text-color);
      background: rgba(0, 0, 0, 0.7);
      padding: 20px 30px;
      border-radius: 10px;
      display: none;
      z-index: 3;
      font-size: 18px;
    }
    
    /* Modal Styling */
    .modal {
      display: none; 
      position: fixed; 
      z-index: 4; 
      left: 0;
      top: 0;
      width: 100%; 
      height: 100%; 
      overflow: auto; 
      background-color: var(--modal-background); 
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: var(--modal-content-bg);
      color: var(--modal-text-color);
      padding: 20px 30px;
      border: 1px solid #888;
      border-radius: 10px;
      width: 80%;
      max-width: 600px;
      position: relative;
      text-align: center;
    }
    
    .close-button {
      color: var(--modal-text-color);
      font-size: 28px;
      font-weight: bold;
      position: absolute;
      top: 10px;
      right: 20px;
      cursor: pointer;
    }
    
    .close-button:hover,
    .close-button:focus {
      color: #bbb;
    }
    
    .modal-message {
      margin-top: 20px;
      font-size: 18px;
      text-align: center;
    }
    
    .modal-options {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .modal-option {
      background-color: var(--button-bg);
      border: none;
      border-radius: 5px;
      color: var(--text-color);
      padding: 10px 20px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 16px;
      width: 100%;
      max-width: 300px;
      text-align: left;
    }
    
    .modal-option:hover {
      background-color: var(--button-hover-bg);
    }

    /* Preprocessing Modal Additional Controls */
    .preprocessing-row {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .preprocessing-row input[type="checkbox"] {
      margin-right: 10px;
    }
    .preprocessing-slider {
      margin: 0 10px;
      flex-grow: 1;
    }
    .preprocessing-value {
      width: 30px;
      text-align: right;
    }
    .worker-options label {
      margin-right: 15px;
    }
    
    /* The overlay canvas (processed frames) */
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none; /* so clicks pass through to underlying elements, if desired */
      z-index: 1; 
    }

    /* The hidden canvas used to extract frame pixel data */
    #frameCanvas {
      display: none;
    }

    /* The OpenCV status indicator (red => loading, green => ready) */
    #opencv-status {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2;
      font-size: 16px;
      font-weight: bold;
      color: red; /* default to red (loading) */
      background-color: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 5px;
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      .control-button {
        padding: 10px 20px;
        font-size: 14px;
        min-width: 120px;
      }
      
      .modal-content {
        width: 90%;
        padding: 15px 20px;
      }
      
      .modal-option {
        font-size: 14px;
        padding: 8px 16px;
      }
      
      #loading-indicator {
        padding: 15px 25px;
        font-size: 16px;
      }
      
      #fps-counter, #orientation-indicator, #camera-fps-indicator {
        font-size: 12px;
        padding: 4px 8px;
      }
      
      #orientation-indicator {
        left: 100px;
      }

      #camera-fps-indicator {
        left: 200px;
      }
    }
  </style>
  
  <!-- Video.js Library (no integrity checks) -->
  <script
    src="https://vjs.zencdn.net/8.0.4/video.min.js"
    defer
  ></script>
</head>
<body>
  
  <!-- Loading Indicator -->
  <div id="loading-indicator">Initializing camera...</div>
  
  <!-- Browser Rendering FPS Counter -->
  <div id="fps-counter">
    <div class="fps-indicator" id="fps-indicator"></div>
    <span id="fps-value">FPS: --</span>
  </div>
  
  <!-- Orientation Indicator -->
  <div id="orientation-indicator">
    <div class="orientation-indicator-circle" id="orientation-circle"></div>
    <span id="orientation-value">Orientation: --</span>
  </div>

  <!-- Camera FPS Indicator -->
  <div id="camera-fps-indicator">
    <div class="camera-fps-indicator-circle" id="camera-fps-circle"></div>
    <span id="camera-fps-value">Camera FPS: --</span>
  </div>

  <!-- OpenCV Status Indicator (changes from red to green when loaded) -->
  <div id="opencv-status">OpenCV</div>

  <!-- Video Stream (background/preview) -->
  <video
    id="camera-stream"
    class="video-js vjs-default-skin"
    autoplay
    muted
    playsinline
    webkit-playsinline
  ></video>

  <!-- Overlay canvas for processed frames -->
  <canvas id="overlayCanvas" width="640" height="480"></canvas>
  <!-- Hidden canvas for extracting raw image pixels -->
  <canvas id="frameCanvas" width="640" height="480"></canvas>

  <!-- Controls -->
  <div class="controls">
    <button class="control-button" id="change-camera" aria-label="Change Camera">Change Camera</button>
    <button class="control-button" id="change-resolution" aria-label="Change Resolution">Change Resolution</button>
    <button class="control-button" id="change-fps" aria-label="Change FPS">Change FPS</button>
    <button class="control-button" id="preprocessing-button" aria-label="Preprocessing Controls">Preprocessing</button>
  </div>
  
  <!-- Modal: Reused for camera/fps/res choices -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
    <div class="modal-content">
      <span class="close-button" id="modal-close" aria-label="Close Modal">&times;</span>
      <div class="modal-message" id="modal-message">Modal Message</div>
      <div class="modal-options" id="modal-options">
        <!-- Dynamic Options Will Be Injected Here -->
      </div>
    </div>
  </div>

  <!-- Modal: Preprocessing Controls -->
  <div id="preprocessing-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="preprocessing-modal-title">
    <div class="modal-content">
      <span class="close-button" id="preprocessing-modal-close" aria-label="Close Modal">&times;</span>
      <h2 id="preprocessing-modal-title">Preprocessing Controls</h2>
      
      <div class="modal-options" id="preprocessing-options">

        <!-- Grayscale -->
        <div class="preprocessing-row">
          <label>
            <input type="checkbox" id="chkGrayscale" />
            Grayscale
          </label>
        </div>

        <!-- Threshold -->
        <div class="preprocessing-row">
          <label>
            <input type="checkbox" id="chkThreshold" />
            Threshold 
          </label>
          <input type="range" id="sliderThreshold" class="preprocessing-slider" min="0" max="100" value="50" />
          <span id="valThreshold" class="preprocessing-value">50</span>
        </div>

        <!-- Edge Detection (Canny) -->
        <div class="preprocessing-row">
          <label>
            <input type="checkbox" id="chkEdges" />
            Edge Detection
          </label>
          <input type="range" id="sliderEdges" class="preprocessing-slider" min="0" max="100" value="50" />
          <span id="valEdges" class="preprocessing-value">50</span>
        </div>

        <!-- Highlights (simple morphological dilation) -->
        <div class="preprocessing-row">
          <label>
            <input type="checkbox" id="chkHighlights" />
            Highlights
          </label>
          <input type="range" id="sliderHighlights" class="preprocessing-slider" min="0" max="100" value="50" />
          <span id="valHighlights" class="preprocessing-value">50</span>
        </div>

        <!-- Brightness -->
        <div class="preprocessing-row">
          <label>
            <input type="checkbox" id="chkBrightness" />
            Brightness
          </label>
          <input type="range" id="sliderBrightness" class="preprocessing-slider" min="0" max="100" value="50" />
          <span id="valBrightness" class="preprocessing-value">50</span>
        </div>

        <hr style="width:100%; margin-top:20px;">

        <!-- Web Worker Options (1, 2, or 4) -->
        <div class="worker-options">
          <label>Web Workers:</label>
          <label><input type="radio" name="workerCount" value="1" checked>1</label>
          <label><input type="radio" name="workerCount" value="2">2</label>
          <label><input type="radio" name="workerCount" value="4">4</label>
        </div>

      </div>
    </div>
  </div>
  
  <!-- Main JavaScript -->
  <script>
    // =======================
    // 1) OpenCV Initialization
    // =======================

    let opencvReady = false;
    cv['onRuntimeInitialized'] = () => {
      console.log('OpenCV is fully initialized');
      opencvReady = true;
      // Change the OpenCV status text color to green
      const opencvStatus = document.getElementById('opencv-status');
      opencvStatus.style.color = 'limegreen';
    };

    // Global object to store user’s preprocessing settings
    const preprocessSettings = {
      grayscale: { enabled: false },
      threshold: { enabled: false, value: 50 },
      edges: { enabled: false, value: 50 },
      highlights: { enabled: false, value: 50 },
      brightness: { enabled: false, value: 50 },
      numWorkers: 1 // default
    };

    // =====================
    // 2) Track Processor
    // =====================

    let trackProcessorReader = null;
    let processingActive = false; // a flag to stop the loop if needed

    // This function sets up the MediaStreamTrackProcessor and continuously reads frames
    async function processCameraStreamWithTrackProcessor(stream) {
      const track = stream.getVideoTracks()[0];

      // If not supported, fallback to the old <video> approach or show an error
      if (typeof MediaStreamTrackProcessor === 'undefined') {
        console.warn('MediaStreamTrackProcessor is not supported in this browser. Fallback to <video> canvas approach.');
        // fallback code if desired, or just keep <video> playing
        return;
      }

      const processor = new MediaStreamTrackProcessor({ track });
      trackProcessorReader = processor.readable.getReader();

      processingActive = true;
      while (processingActive) {
        const result = await trackProcessorReader.read();
        if (result.done) {
          console.log('No more camera frames (stream ended).');
          break;
        }
        const frame = result.value; // This is a VideoFrame
        if (opencvReady) {
          processFrameWithOpenCV(frame);
        }
        frame.close();
      }
    }

    // ===============
    // 3) Preprocessing
    // ===============

    function processFrameWithOpenCV(videoFrame) {
      // Hidden canvas for extracting pixel data
      const frameCanvas = document.getElementById('frameCanvas');
      const ctx = frameCanvas.getContext('2d');

      // Where we draw processed output
      const overlayCanvas = document.getElementById('overlayCanvas');
      const overlayCtx = overlayCanvas.getContext('2d');

      // Size the hidden canvas to match the incoming frame
      frameCanvas.width = videoFrame.displayWidth;
      frameCanvas.height = videoFrame.displayHeight;

      // For some browsers, drawImage(videoFrame) might not be supported directly.
      // If so, you might need createImageBitmap(videoFrame), or videoFrame.copyTo(), etc.
      try {
        ctx.drawImage(videoFrame, 0, 0, frameCanvas.width, frameCanvas.height);
      } catch (err) {
        console.error('drawImage(VideoFrame) not supported:', err);
        return;
      }

      // Extract ImageData
      const imageData = ctx.getImageData(0, 0, frameCanvas.width, frameCanvas.height);

      // Convert to an OpenCV Mat
      let srcMat = cv.matFromImageData(imageData);

      // ========== Apply effects ==========

      // (A) Grayscale
      if (preprocessSettings.grayscale.enabled) {
        cv.cvtColor(srcMat, srcMat, cv.COLOR_RGBA2GRAY, 0);
        // Convert back to RGBA so subsequent ops expecting 4 channels won't break
        cv.cvtColor(srcMat, srcMat, cv.COLOR_GRAY2RGBA, 0);
      }

      // (B) Threshold
      if (preprocessSettings.threshold.enabled) {
        let tVal = (preprocessSettings.threshold.value / 100) * 255;
        cv.threshold(srcMat, srcMat, tVal, 255, cv.THRESH_BINARY);
      }

      // (C) Edge Detection (Canny)
      if (preprocessSettings.edges.enabled) {
        let eVal = preprocessSettings.edges.value; // 0..100
        let t1 = eVal * 2.5; // 0..250
        let t2 = t1 * 1.5;   // 0..375
        let edgeMat = new cv.Mat();
        cv.Canny(srcMat, edgeMat, t1, t2);
        cv.cvtColor(edgeMat, srcMat, cv.COLOR_GRAY2RGBA, 0);
        edgeMat.delete();
      }

      // (D) Highlights (simple morphological dilation for demonstration)
      if (preprocessSettings.highlights.enabled) {
        let kSize = Math.max(1, Math.floor(preprocessSettings.highlights.value / 10)); 
        let kernel = cv.Mat.ones(kSize, kSize, cv.CV_8U);
        let highlightMat = new cv.Mat();
        cv.dilate(srcMat, highlightMat, kernel);
        highlightMat.copyTo(srcMat);
        kernel.delete();
        highlightMat.delete();
      }

      // (E) Brightness
      if (preprocessSettings.brightness.enabled) {
        let bVal = parseInt(preprocessSettings.brightness.value, 10);
        // Map slider 0..100 -> offset range of -50..+50
        let alpha = bVal - 50; 
        cv.convertScaleAbs(srcMat, srcMat, 1, alpha);
      }

      // ========== End Effects ==========

      // Convert back to ImageData
      const processedData = new ImageData(
        new Uint8ClampedArray(srcMat.data),
        srcMat.cols,
        srcMat.rows
      );

      // Resize overlayCanvas to match
      overlayCanvas.width = srcMat.cols;
      overlayCanvas.height = srcMat.rows;
      overlayCtx.putImageData(processedData, 0, 0);

      // Cleanup
      srcMat.delete();
    }

    // =========================
    // 4) The rest of your app
    // =========================

    (function() {
      // Helper to create DOM elements (unchanged from your code)
      const createElement = (tag, attrs = {}, ...children) => {
        const el = document.createElement(tag);
        for (const k in attrs) {
          if (k.startsWith('data-') || k.startsWith('aria-')) {
            el.setAttribute(k, attrs[k]);
          } else if (k === 'class') {
            el.className = attrs[k];
          } else if (k === 'style') {
            el.style.cssText = attrs[k];
          } else {
            el[k] = attrs[k];
          }
        }
        children.forEach(child => {
          if (typeof child === 'string') {
            el.appendChild(document.createTextNode(child));
          } else if (child instanceof Node) {
            el.appendChild(child);
          }
        });
        return el;
      };

      // Simple Modal
      const Modal = (() => {
        const modal = document.getElementById('modal');
        const modalClose = document.getElementById('modal-close');
        const modalMessage = document.getElementById('modal-message');
        const modalOptions = document.getElementById('modal-options');
        
        const show = (message, options = []) => {
          modalMessage.textContent = message;
          modalOptions.innerHTML = '';
          options.forEach(opt => {
            const button = createElement('button', {
              class: 'modal-option',
              onclick: opt.onClick,
              'aria-label': opt.label
            }, opt.label);
            modalOptions.appendChild(button);
          });
          modal.style.display = 'flex';
        };
        
        const close = () => {
          modal.style.display = 'none';
        };
        
        modalClose.addEventListener('click', close);
        window.addEventListener('click', (e) => {
          if (e.target === modal) {
            close();
          }
        });
        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.style.display === 'flex') {
            close();
          }
        });
        
        return { show, close };
      })();
      
      // Browser Rendering FPS Counter
      const FPSCounter = (() => {
        const fpsVal = document.getElementById('fps-value');
        const fpsIndicator = document.getElementById('fps-indicator');
        let frameCount = 0;
        let lastTime = performance.now();
        const targetFPS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fps-target')) || 120;
        const acceptableFPS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fps-acceptable')) || 60;
        
        const update = () => {
          frameCount++;
          const now = performance.now();
          if (now - lastTime >= 1000) {
            const currentFPS = frameCount;
            fpsVal.textContent = `FPS: ${currentFPS}`;
            if (currentFPS >= targetFPS) {
              fpsIndicator.style.backgroundColor = 'green';
            } else if (currentFPS >= acceptableFPS) {
              fpsIndicator.style.backgroundColor = 'yellow';
            } else {
              fpsIndicator.style.backgroundColor = 'red';
            }
            frameCount = 0;
            lastTime = now;
          }
          requestAnimationFrame(update);
        };
        
        const start = () => requestAnimationFrame(update);
        return { start };
      })();
      
      // Camera Stream Module
      const CameraStream = (() => {
        const videoElement = document.getElementById('camera-stream');
        const loadingIndicator = document.getElementById('loading-indicator');
        const orientationValue = document.getElementById('orientation-value');
        const orientationCircle = document.getElementById('orientation-circle');
        const cameraFpsValue = document.getElementById('camera-fps-value');
        
        let currentStream = null;
        let currentCameraIndex = 0;
        
        // By default, let's do 720p
        let currentResolution = {
          width: 1280,
          height: 720,
          label: 'Portrait 1280x720',
          orientation: 'landscape'
        };
        
        // By default, request 60 fps
        let userChosenFps = 60;
        
        let cameras = [];
        let isChangingStream = false;
        let player = null;
        let debounceTimeout;
        
        // Example resolution list (unchanged, but note labels are swapped)
        const resolutions = [
          { label: 'Landscape 480x640', width: 480, height: 640, orientation: 'portrait' },
          { label: 'Portrait 640x480', width: 640, height: 480, orientation: 'landscape' },
          { label: 'Landscape 720x1280', width: 720, height: 1280, orientation: 'portrait' },
          { label: 'Portrait 1280x720', width: 1280, height: 720, orientation: 'landscape' },
          { label: 'Landscape 1080x1920', width: 1080, height: 1920, orientation: 'portrait' },
          { label: 'Portrait 1920x1080', width: 1920, height: 1080, orientation: 'landscape' },
          { label: 'Landscape 1440x2560', width: 1440, height: 2560, orientation: 'portrait' },
          { label: 'Portrait 2560x1440', width: 2560, height: 1440, orientation: 'landscape' },
          { label: 'Landscape 2160x3840', width: 2160, height: 3840, orientation: 'portrait' },
          { label: 'Portrait 3840x2160', width: 3840, height: 2160, orientation: 'landscape' }
        ];
        
        // Orientation indicator only
        const getDeviceOrientation = () => {
          if (window.screen.orientation && window.screen.orientation.type) {
            return window.screen.orientation.type.startsWith('portrait') ? 'portrait' : 'landscape';
          }
          return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
        };
        
        const updateOrientationIndicator = () => {
          const orientation = getDeviceOrientation();
          orientationValue.textContent = `Orientation: ${orientation}`;
          if (orientation === 'portrait') {
            orientationCircle.style.backgroundColor = 'blue';
          } else if (orientation === 'landscape') {
            orientationCircle.style.backgroundColor = 'purple';
          } else {
            orientationCircle.style.backgroundColor = 'gray';
          }
          console.log(`Orientation: ${orientation}`);
        };
        
        const updateCameraFpsIndicator = (fps) => {
          cameraFpsValue.textContent = `Camera FPS: ${fps}`;
          console.log(`Camera FPS updated: ${fps}`);
        };
        
        const initializeVideoJS = () => {
          if (!player) {
            player = videojs('camera-stream', {
              autoplay: true,
              muted: true,
              controls: false,
              fluid: true
            });
            console.log('Video.js initialized');
          }
        };
        
        const resizeVideo = () => {
          console.log('Window or orientation changed → resizing if needed.');
        };
        
        const getCameras = async () => {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            cameras = devices.filter(d => d.kind === 'videoinput');
            console.log(`Found ${cameras.length} camera(s).`);
            if (cameras.length === 0) {
              alert('No cameras found on this device.');
            }
          } catch (err) {
            console.error('Error enumerating devices:', err);
            alert('Unable to access camera devices.');
          }
        };
        
        const displayStreamSettings = (settings) => {
          const msg = `Current Resolution: ${settings.width}x${settings.height}, FPS: ${settings.frameRate}`;
          Modal.show(msg, [{ label: 'OK', onClick: Modal.close }]);
          console.log(msg);
        };
        
        const startStream = async () => {
          if (isChangingStream) return;
          isChangingStream = true;
          
          try {
            loadingIndicator.style.display = 'block';
            updateOrientationIndicator();
            
            // Stop old stream
            if (currentStream) {
              console.log('Stopping previous stream tracks...');
              currentStream.getTracks().forEach(t => t.stop());
            }
            
            const constraints = {
              video: {
                deviceId: cameras[currentCameraIndex]?.deviceId
                  ? { exact: cameras[currentCameraIndex].deviceId }
                  : undefined,
                facingMode: 'environment',
                width: { ideal: currentResolution.width },
                height: { ideal: currentResolution.height },
                frameRate: { ideal: userChosenFps, max: userChosenFps }
              }
            };
            console.log('Requesting media with:', constraints);
            
            let newStream;
            try {
              newStream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (err) {
              // If Overconstrained => show modal, do not fallback
              if (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError') {
                console.error('Overconstrained: device can’t do that FPS/res combo.');
                Modal.show(
                  `Your device does not support ${currentResolution.width}x${currentResolution.height} @ ${userChosenFps}fps.`,
                  [{ label: 'OK', onClick: Modal.close }]
                );
                throw err;
              } else {
                throw err;
              }
            }
            
            currentStream = newStream;
            // For a normal <video> preview:
            videoElement.srcObject = currentStream;
            await videoElement.play();
            
            console.log('Stream started, video playing');
            initializeVideoJS();
            
            // Use the new MediaStreamTrackProcessor approach
            processCameraStreamWithTrackProcessor(currentStream);
            
            // Actual track settings
            const track = currentStream.getVideoTracks()[0];
            const s = track.getSettings();
            console.log(`Actual: ${s.width}x${s.height} @ ${s.frameRate}fps`);
            updateCameraFpsIndicator(s.frameRate);
            displayStreamSettings(s);
            
            // If resolution mismatch
            if (
              (s.width !== currentResolution.width && s.height !== currentResolution.height) &&
              (s.width !== currentResolution.height && s.height !== currentResolution.width)
            ) {
              Modal.show(
                `Requested ${currentResolution.width}x${currentResolution.height}, got ${s.width}x${s.height} instead.`,
                [{ label: 'OK', onClick: Modal.close }]
              );
              console.warn(`Resolution mismatch: asked for ${currentResolution.width}x${currentResolution.height}, got ${s.width}x${s.height}`);
            }
            
          } catch (err) {
            console.error('Error starting stream:', err);
            if (err.name === 'NotAllowedError') {
              alert('Camera access was denied. Please enable it in your browser settings.');
            } else if (err.name === 'NotFoundError') {
              alert('No camera device found.');
            } else if (err.name !== 'OverconstrainedError' && err.name !== 'ConstraintNotSatisfiedError') {
              alert(`Error accessing camera: ${err.name}`);
            }
          } finally {
            loadingIndicator.style.display = 'none';
            isChangingStream = false;
          }
        };
        
        const switchCamera = async () => {
          if (cameras.length < 2) {
            Modal.show('No alternate cameras found.');
            return;
          }
          
          const camOptions = cameras.map((cam, i) => ({
            label: cam.label || `Camera ${i + 1}`,
            onClick: () => {
              currentCameraIndex = i;
              Modal.close();
              startStream();
              console.log(`Switched to camera index: ${i}`);
            }
          }));
          
          Modal.show('Select a camera:', camOptions);
        };
        
        const switchResolution = () => {
          const opts = resolutions.map(r => ({
            label: r.label,
            onClick: async () => {
              currentResolution = { 
                width: r.width,
                height: r.height,
                orientation: r.orientation,
                label: r.label
              };
              Modal.close();
              await startStream();
              console.log(`Switched resolution: ${r.label}`);
            }
          }));
          
          Modal.show('Select a resolution:', opts);
        };
        
        const switchFps = () => {
          const fpsOpts = [
            {
              label: '30 FPS',
              onClick: async () => {
                userChosenFps = 30;
                Modal.close();
                await startStream();
                console.log('Switched to 30 FPS');
              }
            },
            {
              label: '60 FPS',
              onClick: async () => {
                userChosenFps = 60;
                Modal.close();
                await startStream();
                console.log('Switched to 60 FPS');
              }
            }
          ];
          
          Modal.show('Select FPS:', fpsOpts);
        };
        
        const debounce = (func, delay = 300) => {
          return function(...args) {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => func.apply(this, args), delay);
          };
        };
        
        const handleOrientationChange = () => {
          console.log('Orientation changed');
          updateOrientationIndicator();
          resizeVideo();
        };
        
        const init = async () => {
          await getCameras();
          await startStream();
          
          window.addEventListener('resize', resizeVideo);
          window.addEventListener('orientationchange', handleOrientationChange);
          
          navigator.mediaDevices.addEventListener('devicechange', async () => {
            await getCameras();
            console.log('Device change detected');
          });
        };
        
        return { init, switchCamera, switchResolution, switchFps };
      })();
      
      // Permissions Module
      const Permissions = (() => {
        const checkPermissions = async () => {
          try {
            const status = await navigator.permissions.query({ name: 'camera' });
            handlePermissionState(status.state);
            
            status.onchange = () => {
              handlePermissionState(status.state);
            };
          } catch (err) {
            console.error('Error checking camera perms:', err);
            Modal.show('An error occurred while accessing camera permissions.');
          }
        };
        
        const handlePermissionState = (st) => {
          switch(st) {
            case 'denied':
              Modal.show('Camera access denied. Enable it in your browser settings.');
              break;
            case 'prompt':
              requestCameraAccess();
              break;
            case 'granted':
              CameraStream.init();
              break;
            default:
              break;
          }
        };
        
        const requestCameraAccess = async () => {
          try {
            await navigator.mediaDevices.getUserMedia({ video: true });
            Modal.show(
              'Camera access granted. The page will refresh to start the camera stream.',
              [
                {
                  label: 'Continue',
                  onClick: () => {
                    Modal.close();
                    location.reload();
                  }
                }
              ]
            );
          } catch (error) {
            console.error('Error requesting camera access:', error);
            Modal.show('Camera access is required to use this application.');
          }
        };
        
        const init = () => {
          checkPermissions();
        };
        
        return { init };
      })();
      
      // Initialize Everything
      document.addEventListener('DOMContentLoaded', () => {
        // Start the rendering FPS loop
        FPSCounter.start();

        // Check camera perms, then init camera if granted
        Permissions.init();

        // Hook up controls
        document.getElementById('change-camera')
          .addEventListener('click', CameraStream.switchCamera);
        document.getElementById('change-resolution')
          .addEventListener('click', debounce(CameraStream.switchResolution));
        document.getElementById('change-fps')
          .addEventListener('click', debounce(CameraStream.switchFps));
        
        // Preprocessing modal open/close
        const preprocessingModal = document.getElementById('preprocessing-modal');
        document.getElementById('preprocessing-button').addEventListener('click', () => {
          preprocessingModal.style.display = 'flex';
        });
        document.getElementById('preprocessing-modal-close').addEventListener('click', () => {
          preprocessingModal.style.display = 'none';
        });

        // Attach event listeners for each effect
        document.getElementById('chkGrayscale').addEventListener('change', (e) => {
          preprocessSettings.grayscale.enabled = e.target.checked;
        });
        const sliderThreshold = document.getElementById('sliderThreshold');
        sliderThreshold.addEventListener('input', (e) => {
          let val = parseInt(e.target.value, 10);
          document.getElementById('valThreshold').textContent = val;
          preprocessSettings.threshold.value = val;
        });
        document.getElementById('chkThreshold').addEventListener('change', (e) => {
          preprocessSettings.threshold.enabled = e.target.checked;
        });

        const sliderEdges = document.getElementById('sliderEdges');
        sliderEdges.addEventListener('input', (e) => {
          let val = parseInt(e.target.value, 10);
          document.getElementById('valEdges').textContent = val;
          preprocessSettings.edges.value = val;
        });
        document.getElementById('chkEdges').addEventListener('change', (e) => {
          preprocessSettings.edges.enabled = e.target.checked;
        });

        const sliderHighlights = document.getElementById('sliderHighlights');
        sliderHighlights.addEventListener('input', (e) => {
          let val = parseInt(e.target.value, 10);
          document.getElementById('valHighlights').textContent = val;
          preprocessSettings.highlights.value = val;
        });
        document.getElementById('chkHighlights').addEventListener('change', (e) => {
          preprocessSettings.highlights.enabled = e.target.checked;
        });

        const sliderBrightness = document.getElementById('sliderBrightness');
        sliderBrightness.addEventListener('input', (e) => {
          let val = parseInt(e.target.value, 10);
          document.getElementById('valBrightness').textContent = val;
          preprocessSettings.brightness.value = val;
        });
        document.getElementById('chkBrightness').addEventListener('change', (e) => {
          preprocessSettings.brightness.enabled = e.target.checked;
        });

        // Web Worker count
        const workerRadios = document.getElementsByName('workerCount');
        workerRadios.forEach(radio => {
          radio.addEventListener('change', (e) => {
            preprocessSettings.numWorkers = parseInt(e.target.value, 10);
            console.log('Selected workers:', preprocessSettings.numWorkers);
            // You would initialize or re-initialize your web-workers here if needed
          });
        });
      });
    })();

  </script>
  
</body>
</html>
